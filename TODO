$Id$

- PRI 1: OO-Architecture Redesign
  - si/font.* -> Singleton<UVFont> mit HashMap of Font Objs
  - STL: stl.h -> stl.h string.h (schnelleres compile)
  - SDL: wech mit hardware surfaces
  - OS/SysDep: lib oder si? static oder Singleton?
  - lib/observer.* benutzen, um ui von pd und dm zu separieren
  - progress.* in allgemeines, von PD unabhaengiges Widget refactoren
    - model interface (virtual class)
  - parser_txt.* refactoren:
    - abstractparser.*, txtparser.*/xmlparser.*/htmparser.*, parserhandler.*
  - ui/navigator.{h,cpp} -> ui/splash.{h,cpp} ui/abstractwidget.{h,cpp}
                            ui/rootpane.{h,cpp}

- Nachrichten parsen (für Karte relevante)
  - Tokenizing fertig bis auf letzte Bugs (H220)
  - Parsing relevanter Daten als nächstes
    - Zonendaten
    - Income-Stats (?)
- Maushandling: Zoom, Zentrieren, Scrollen, Koordinaten anzeigen.
  - Hierarchisches Widget-System
    - Widgets und Containers

Weiter gemäss RoadMap im Wiki:
https://projects.roe.ch/trac/uvnav/wiki/RoadMap

------------------------------------------------------------------------------

== UNSORTED ==

- sidebar mit objektliste als einfaches mittel gegen die unübersichtlichkeit
  - deaktiviertbar
  - evtl zoom-minimap
  - wie mit übersichts-minimap koppeln?

== HOHE PRIORITAET ==

- Besseres Dirty Rect Verhalten / DR-Correctness der Objekte
  - Kreis nicht zeichnen wenn komplett reingezoomt
  - Linie nicht zeichnen wenn sie das Rect nicht schneidet
  - weitere?

- BUG: gfxPrimitives zeichnen daneben für sehr kleine Zoomfaktoren
  - AA-Ellipse
    - Eigene Routinen mit 32bit Arithmetik implementieren
  - Linien mit Koords > 16 bit
    - Eigene Routinen mit 32bit Arithmetik implementieren
    - oder allen Linien zeichnenden Code mit "dirty Rect"-Correctness versehen

- Geschwindigkeit / Usability optimieren
  - SDL_Surface temp als zweiten buffer führen,
    generell nur dort reinzeichnen (fuzzy dirty rect matching), und dann
    strikte nach dirty rect auf screen blitten.
    analyse: verlust: const. gewinn durch dirty rects: linear.
    - dirty rects benutzen für scrolling (wie copy gestalten?)
    - dirty rects benutzen für mouse handling
    - dirty rects benutzen für windows
    - ...
  - Verschiedene Detailstufen einführen
  - Objekte sinnvoll verkleinern, eventuell clusterweise zu gruppen
    zusammenfassen (schwierig?)
  - Eventuell dann mal noch Speed verbessern mit eigenen Datenstrukturen
  - Alle Labels abgekoppelt zeichnen - mit Shadow-Rect über alle andere Objs
    - API für abgekoppeltes zeichnen
      Liste aller zu zeichnenden Labels
    - evtl Quick'n'Dirty optimieren; überschneidende Labels -> "..."
  - Abgesetztes zeichnen?
    - anstatt direkt zeichnen nur zu zeichnende objekte registrieren
    - abgesetzt werden die objekte dann in der richtigen reihenfolge
      gezeichnet
    - evtl schweine-langsam?

- UVMap
  - Mehr Informationen zeichnen
  - Schlaues System um die gezeichneten Infos individuell zu kontrollieren
  - Minimap
  - Statusinformationen in ein sauberes Info-Overlay überführen.
  - Maushandling einführen
    - Koordinaten laufend anzeigen
  - Zeichenreihenfolge
  - Such-Overlay à la Celestia
  - Neue Map Keys:
    Ins: aktuelle Ansicht speichern
    Del: aktuelle Ansicht verwerfen und zur letzten gespeicherten Ansicht
         zurückkehren (Stack)
  - UVMap / UVConf: Zoomsettings schöner implementieren
    - per Dimension Einstellungen speichern

- Freund/Feind-Erkennung
  - zentralisieren
  - Schiffe färben

- UVFontCache
  - cachen und blitten anstatt immer neu rendern und blitten



== MITTLERE PRIORITAET ==

- Win32-Benutzbarkeit
  - Sichtbare Fehlermeldung
  - Auswertungs-Auswahl-Dialog

- UVDraw
  - eigene Funktionen aus SDL_gfx klauen mit strikter rect unterstützung

- UVImages
  - Schnelleren Zoom-Code benutzen
    - SDL_gfx generell obsolet?
  - Low-Q Variante unterstützen für Fast-Scaling
  - In X Zoomfaktoren gezoomte Planetenbilder prescalen und cachen
    - preload(array of w/h's)
    - Planetenbilder gesondert behandeln (?!)
  - Sämtliche je gerenderten Bilder cachen (hash_map)
  - von double Faktor auf long Höhe umstellen, konsequent beim Caching

- Nachrichten parsen
  - parse_nachrichten implementieren
  - UVWelt erweitern

- DEBUG / PRINT_DEBUG einführen und generell sauber managen
  - debuglevels?
  - debugcategories? [<-]

- UVGUIWidgets
  - ...

- detailansicht menuliste (depends on UVGUIWidgets)
  - auswahlrechteck startet detailansicht mit selektierten objects
  - schiffe etc immer mit (mini) signatur und richtungsvektor
  - planeten mit symbol
  - sortieren nach ...
  - auswahl eines objekts, gleiche aktionen wie im kartenfenster

- UVWelt
  - Spieler ausbauen. Für jeden Spieler möglichst viele Informationen
    speichern, inklusive Statistik à la wieviele Objekte welchen Typs
    besitzt er.
  - korrektes destroyen aller Objekte



== TIEFE PRIORITAET ==

- HUD-Switcher
  - nix / nur titel oben / plus distanzmesser / plus x/y / plus debug

- Unterstützung für komprimierte Auswertungen
  - ZIP à la Meng in allen Variationen (mühsam)
  - gzip
  - bzip2

- Mehrere Auswertungen
  - 1 Spieler / mehrere Spieler
    - a) alte daten erkennen und intelligent ersetzen
         - UVWelt serialisieren und wieder einlesen
    - b) history-objekte führen
    - c) alt-modus beim parsen, der nur planetendaten parst
         - ineffizient, skaliert schlecht
    - d) planetendaten-cache/db
         - SQLite DB als Store
         - UVPlanetendaten verwaltet Planetendaten
         - wohin mit History?
    - e) UVWelt als Auswertungsdatei ausgeben
         - interessant, evtl auch als zusatzfeature zu anderer lösung
         - ineffizient
         - merging notwendig
    - f) DB mit kompletter Auswertungs-History
         - SQLite DB als Store
           =ODER=
           XML-Dok als Store
         - UVHistory stellt vergangene Daten zu Verfuegung
           inklusive effizientem Enum von Dingen, die noch aktuell sind
           und inklusive Quellenangabe (index in tbl_source (spieler/sz/file))
    - Wie Fremdauswertungen dazuladen?
    - Wie Fremdauswertungen anschauen, mit / ohne Zusatzwissen?

- Imperatoren-Support
  - parse_imp_*
  - Display-Support
    - Extra Hash-Map für alle Verbindungen zum schnellen anzeigen
      planeten-nummer x planeten-nummer -> x1, y1, x2, y2

- billigen demo-effekt nach splash screen als übergang zum navigator
  (warp-effekt wäre ultra-cool)

- Statistik-Features

- Splash-Screen beim Laden mit Zeichenerklärung für die verwendeten Signaturen
  - erst wenn Grafix fix entschieden ist

- Keyboard Belegung konfigurierbar machen
  - Set Keys Window

- Release Engineering
  - lib/pcre nur compilen falls keine System-Lib gefunden (konfigurierbar)

- Web
  - LXR benutzen für cross-reference des codes zum protzen :)
    http://lxr.linux.no/

- Charset Durcheinander lösen
  - Genereller Unicode support
  - Keystrokes nach Unicode
  - interne strings?
  - auswertung nach unicode
  - iconv?

- Hardware surfaces:
  - probleme wenn windowed:
    - in fremde windows zeichnen
  - hardware unter unix nur als root
    - message ausgeben
  - hardware langsamer als software
    - timing einbauen und testen
  - nur so und so viel video-memory
    - wie detecten wenn memory full?
  - double-buf: verschiedene modi!
    - wie detecten?
    - wie handeln wenn detected?

- Exceptions "richtig" implementieren
  - eigene Klassenhierarchie
  - Fehlertypen erlauben
  - graceful Exit ermöglichen

- Warnings "richtig" implementieren
  - zentrale WARN(); Facility

- Verbleibende verstreute TODOs und *** und FIXMEs abarbeiten

