$Id$


== post 0.0.1 ==

- Wiki: Roadmap
- Wiki: Downloads
- Wiki: Screenshots


Weiter gemäss Roadmap im Wiki:
https://projects.roe.ch/trac/uvnav/wiki/RoadMap


------------------------------------------------------------------------------

== HOHE PRIORITAET ==

- Autotools Upgrade 257->259 & 17->18

- Besseres Dirty Rect Verhalten / DR-Correctness der Objekte
  - Kreis nicht zeichnen wenn komplett reingezoomt
  - Linie nicht zeichnen wenn sie das Rect nicht schneidet
  - weitere?

- BUG: gfxPrimitives zeichnen daneben für sehr kleine Zoomfaktoren
  - AA-Ellipse
    - Eigene Routinen mit 32bit Arithmetik implementieren
  - Linien mit Koords > 16 bit
    - Eigene Routinen mit 32bit Arithmetik implementieren
    - oder allen Linien zeichnenden Code mit "dirty Rect"-Correctness versehen

- Intelligentes auto-scaling / positioning
  - in UVWelt::set_* die groessten und kleinsten koordinaten verwalten
  - zoom standardwerte daraus berechnen
    - eventuell auch gespeicherte werte damit überschreiben
      wenn kein exakter match für die sternzeit gefunden wurde.
      benötigt eventuell API change in UVConf.
  - zoom limitieren wenn alles sichtbar
  - funktion um direkt rauszuspringen (View All)
  - Keys:
    PgUp/Dn: manueller Zoom
    Home: alle eigenen sichtbar
    End: alles bekannte sichtbar
    Ins: aktuelle Ansicht speichern
    Del: aktuelle Ansicht verwerfen und zur letzten gespeicherten Ansicht
         zurückkehren (Stack)

- Statistik
  - UVWelt zählt Anzahl Objekte jedes relevanten Typs
  - Statistik ausgeben in UVNavigator nach Parsen
  - Statistik pro Dim ausgeben bei Dim Switch

- Geschwindigkeit / Usability optimieren
  - SDL_Surface temp als zweiten buffer führen,
    generell nur dort reinzeichnen (fuzzy dirty rect matching), und dann
    strikte nach dirty rect auf screen blitten.
    analyse: verlust: const. gewinn durch dirty rects: linear.
    - dirty rects benutzen für scrolling (wie copy gestalten?)
    - dirty rects benutzen für mouse handling
    - dirty rects benutzen für windows
    - ...
  - Verschiedene Detailstufen einführen
  - Objekte sinnvoll verkleinern, eventuell clusterweise zu gruppen
    zusammenfassen (schwierig?)
  - Eventuell dann mal noch Speed verbessern mit eigenen Datenstrukturen
  - Objektgroessen ueberdenken von usability her
    - nicht nur mindest, sondern auch maximalgroesse der objekte festlegen,
      und zoom-code entsprechend anpassen
    - von min/max objektgroessen auf schoene funktion umsteigen
    - Planeten sind bei grossem Zoom relativ, bei kleinem Zoom fix gross

- UVMap
  - Mehr Informationen zeichnen
  - Schlaues System um die gezeichneten Infos individuell zu kontrollieren
  - Minimap
  - Statusinformationen in ein sauberes Info-Overlay überführen.
  - Maushandling einführen
  - Zeichenreihenfolge
  - Such-Overlay à la Celestia

- UVFontCache
  - cachen und blitten anstatt immer neu rendern und blitten



== MITTLERE PRIORITAET ==

- UVDraw
  - eigene Funktionen aus SDL_gfx klauen mit strikter rect unterstützung

- UVImages
  - Schnelleren Zoom-Code benutzen
    - SDL_gfx generell obsolet?
  - Low-Q Variante unterstützen für Fast-Scaling
  - In X Zoomfaktoren gezoomte Planetenbilder prescalen und cachen
    - preload(array of w/h's)
    - Planetenbilder gesondert behandeln (?!)
  - Sämtliche je gerenderten Bilder cachen (hash_map)
  - von double Faktor auf long Höhe umstellen, konsequent beim Caching

- Nachrichten parsen
  - parse_nachrichten implementieren
  - UVWelt erweitern

- DEBUG / PRINT_DEBUG einführen und generell sauber managen
  - debuglevels?
  - debugcategories? [<-]

- UVGUIWidgets
  - ...

- Parser
  - Parser optimieren
    - regexps zentralisieren

- UVWelt
  - Spieler ausbauen. Für jeden Spieler möglichst viele Informationen
    speichern, inklusive Statistik à la wieviele Objekte welchen Typs
    besitzt er.
  - korrektes destroyen aller Objekte



== TIEFE PRIORITAET ==

- Unterstützung für komprimierte Auswertungen
  - ZIP à la Meng in allen Variationen (mühsam)
  - gzip
  - bzip2

- Mehrere Auswertungen
  - 1 Spieler
    - a) alte daten erkennen und intelligent ersetzen
         BEDINGT SERIALISIERUNG VON UVWelt
    - b) history-objekte führen
    - c) alt-modus beim parsen, der nur planetendaten parst
    - d) planetendaten-cache/db
    - e) UVWelt als Auswertungsdatei serialisieren (interessant!)
  - Mehrere Spieler
    - intelligent mergen

- Imperatoren-Support
  - parse_imp_*
  - Display-Support
    - Extra Hash-Map für alle Verbindungen zum schnellen anzeigen
      planeten-nummer x planeten-nummer -> x1, y1, x2, y2

- billigen demo-effekt nach splash screen als übergang zum navigator
  (warp-effekt wäre ultra-cool)

- Splash-Screen beim Laden mit Zeichenerklärung für die verwendeten Signaturen

- Keyboard Belegung konfigurierbar machen
  - Set Keys Window

- Release Engineering
  - PCRE++ korrekt in autoconf einbauen
  - SDL_* korrekt in autoconf einbauen
  - Debug code in autoconf einbinden
  - MingW32 crosscompiling (yeeha!)
  - LXR benutzen für cross-reference des codes zum protzen :)
    http://lxr.linux.no/

- Charset Durcheinander lösen
  - Genereller Unicode support
  - Keystrokes nach Unicode
  - interne strings?
  - auswertung nach unicode
  - iconv?

- Hardware surfaces:
  - probleme wenn windowed:
    - in fremde windows zeichnen
  - hardware unter unix nur als root
    - message ausgeben
  - hardware langsamer als software
    - timing einbauen und testen
  - nur so und so viel video-memory
    - wie detecten wenn memory full?
  - double-buf: verschiedene modi!
    - wie detecten?
    - wie handeln wenn detected?

- Window Resizable
  - testen
  - flicken

- Exceptions "richtig" implementieren
  - eigene Klassenhierarchie
  - Fehlertypen erlauben
  - graceful Exit ermöglichen

- Warnings "richtig" implementieren
  - zentrale WARN(); Facility

- Historische Auswertungen einlesen

- Verbleibende verstreute TODOs und *** und FIXMEs abarbeiten

