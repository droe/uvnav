$Id$

== 0.0.2 ==

dann wär auch schon bald wieder mal n release möglich...
eventuell noch n paar low-pri's killen... TODO checken


Weiter gemäss RoadMap im Wiki:
https://projects.roe.ch/trac/uvnav/wiki/RoadMap

------------------------------------------------------------------------------

== HOHE PRIORITAET ==

- Besseres Dirty Rect Verhalten / DR-Correctness der Objekte
  - Kreis nicht zeichnen wenn komplett reingezoomt
  - Linie nicht zeichnen wenn sie das Rect nicht schneidet
  - weitere?

- BUG: gfxPrimitives zeichnen daneben für sehr kleine Zoomfaktoren
  - AA-Ellipse
    - Eigene Routinen mit 32bit Arithmetik implementieren
  - Linien mit Koords > 16 bit
    - Eigene Routinen mit 32bit Arithmetik implementieren
    - oder allen Linien zeichnenden Code mit "dirty Rect"-Correctness versehen

- Statistik
  - UVWelt zählt Anzahl Objekte jedes relevanten Typs
  - Statistik ausgeben in UVNavigator nach Parsen
  - Statistik pro Dim ausgeben bei Dim Switch

- Geschwindigkeit / Usability optimieren
  - SDL_Surface temp als zweiten buffer führen,
    generell nur dort reinzeichnen (fuzzy dirty rect matching), und dann
    strikte nach dirty rect auf screen blitten.
    analyse: verlust: const. gewinn durch dirty rects: linear.
    - dirty rects benutzen für scrolling (wie copy gestalten?)
    - dirty rects benutzen für mouse handling
    - dirty rects benutzen für windows
    - ...
  - Verschiedene Detailstufen einführen
  - Objekte sinnvoll verkleinern, eventuell clusterweise zu gruppen
    zusammenfassen (schwierig?)
  - Eventuell dann mal noch Speed verbessern mit eigenen Datenstrukturen
  - Alle Labels abgekoppelt zeichnen - mit Shadow-Rect über alle andere Objs
    - API für abgekoppeltes zeichnen
      Liste aller zu zeichnenden Labels
    - evtl Quick'n'Dirty optimieren; überschneidende Labels -> "..."
  - Objektgroessen ueberdenken von usability her
    - nicht nur mindest, sondern auch maximalgroesse der objekte festlegen,
      und zoom-code entsprechend anpassen
    - von min/max objektgroessen auf schoene funktion umsteigen
    - Planeten sind bei grossem Zoom relativ, bei kleinem Zoom fix gross

- UVMap
  - Mehr Informationen zeichnen
  - Schlaues System um die gezeichneten Infos individuell zu kontrollieren
  - Minimap
  - Statusinformationen in ein sauberes Info-Overlay überführen.
  - Maushandling einführen
    - Koordinaten laufend anzeigen
  - Zeichenreihenfolge
  - Such-Overlay à la Celestia
  - Neue Map Keys:
    Ins: aktuelle Ansicht speichern
    Del: aktuelle Ansicht verwerfen und zur letzten gespeicherten Ansicht
         zurückkehren (Stack)
  - UVMap / UVConf: Zoomsettings schöner implementieren
    - per Dimension Einstellungen speichern

- Freund/Feind-Erkennung
  - zentralisieren

- UVFontCache
  - cachen und blitten anstatt immer neu rendern und blitten



== MITTLERE PRIORITAET ==

- Win32-Benutzbarkeit
  - Sichtbare Fehlermeldung
  - Auswertungs-Auswahl-Dialog

- UVDraw
  - eigene Funktionen aus SDL_gfx klauen mit strikter rect unterstützung

- UVImages
  - Schnelleren Zoom-Code benutzen
    - SDL_gfx generell obsolet?
  - Low-Q Variante unterstützen für Fast-Scaling
  - In X Zoomfaktoren gezoomte Planetenbilder prescalen und cachen
    - preload(array of w/h's)
    - Planetenbilder gesondert behandeln (?!)
  - Sämtliche je gerenderten Bilder cachen (hash_map)
  - von double Faktor auf long Höhe umstellen, konsequent beim Caching

- Nachrichten parsen
  - parse_nachrichten implementieren
  - UVWelt erweitern

- DEBUG / PRINT_DEBUG einführen und generell sauber managen
  - debuglevels?
  - debugcategories? [<-]

- UVGUIWidgets
  - ...

- UVWelt
  - Spieler ausbauen. Für jeden Spieler möglichst viele Informationen
    speichern, inklusive Statistik à la wieviele Objekte welchen Typs
    besitzt er.
  - korrektes destroyen aller Objekte
  - set_partie eliminieren



== TIEFE PRIORITAET ==

- Unterstützung für komprimierte Auswertungen
  - ZIP à la Meng in allen Variationen (mühsam)
  - gzip
  - bzip2

- Mehrere Auswertungen
  - 1 Spieler / mehrere Spieler
    - a) alte daten erkennen und intelligent ersetzen
         - UVWelt serialisieren und wieder einlesen
    - b) history-objekte führen
    - c) alt-modus beim parsen, der nur planetendaten parst
         - ineffizient, skaliert schlecht
    - d) planetendaten-cache/db
         - SQLite DB als Store
         - UVPlanetendaten verwaltet Planetendaten
         - wohin mit History?
    - e) UVWelt als Auswertungsdatei ausgeben
         - interessant, evtl auch als zusatzfeature zu anderer lösung
         - ineffizient
         - merging notwendig
    - f) DB mit kompletter Auswertungs-History
         - SQLite DB als Store
           =ODER=
           XML-Dok als Store
         - UVHistory stellt vergangene Daten zu Verfuegung
           inklusive effizientem Enum von Dingen, die noch aktuell sind
           und inklusive Quellenangabe (index in tbl_source (spieler/sz/file))

- Imperatoren-Support
  - parse_imp_*
  - Display-Support
    - Extra Hash-Map für alle Verbindungen zum schnellen anzeigen
      planeten-nummer x planeten-nummer -> x1, y1, x2, y2

- billigen demo-effekt nach splash screen als übergang zum navigator
  (warp-effekt wäre ultra-cool)

- Splash-Screen beim Laden mit Zeichenerklärung für die verwendeten Signaturen
  - erst wenn Grafix fix entschieden ist

- Keyboard Belegung konfigurierbar machen
  - Set Keys Window

- Release Engineering
  - lib/pcre nur compilen falls keine System-Lib gefunden (konfigurierbar)

- Web
  - LXR benutzen für cross-reference des codes zum protzen :)
    http://lxr.linux.no/

- Charset Durcheinander lösen
  - Genereller Unicode support
  - Keystrokes nach Unicode
  - interne strings?
  - auswertung nach unicode
  - iconv?

- Hardware surfaces:
  - probleme wenn windowed:
    - in fremde windows zeichnen
  - hardware unter unix nur als root
    - message ausgeben
  - hardware langsamer als software
    - timing einbauen und testen
  - nur so und so viel video-memory
    - wie detecten wenn memory full?
  - double-buf: verschiedene modi!
    - wie detecten?
    - wie handeln wenn detected?

- Exceptions "richtig" implementieren
  - eigene Klassenhierarchie
  - Fehlertypen erlauben
  - graceful Exit ermöglichen

- Warnings "richtig" implementieren
  - zentrale WARN(); Facility

- Verbleibende verstreute TODOs und *** und FIXMEs abarbeiten

